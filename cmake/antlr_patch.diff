diff --git a/runtime/Cpp/runtime/CMakeLists.txt b/runtime/Cpp/runtime/CMakeLists.txt
index baf46ca..35f00ff 100644
--- a/runtime/Cpp/runtime/CMakeLists.txt
+++ b/runtime/Cpp/runtime/CMakeLists.txt
@@ -26,8 +26,8 @@ file(GLOB libantlrcpp_SRC
 add_library(antlr4_shared SHARED ${libantlrcpp_SRC})
 add_library(antlr4_static STATIC ${libantlrcpp_SRC})
 
-set(LIB_OUTPUT_DIR "${CMAKE_HOME_DIRECTORY}/dist") # put generated libraries here.
-message(STATUS "Output libraries to ${LIB_OUTPUT_DIR}")
+#set(LIB_OUTPUT_DIR "Output directory" "${CMAKE_HOME_DIRECTORY}/dist") # put generated libraries here.
+#message(STATUS "Output libraries to ${LIB_OUTPUT_DIR}")
 
 # make sure 'make' works fine even if ${LIB_OUTPUT_DIR} is deleted.
 add_custom_target(make_lib_output_dir ALL
@@ -69,10 +69,7 @@ if (ANTLR_BUILD_CPP_TESTS)
   gtest_discover_tests(antlr4_tests)
 endif()
 
-if(CMAKE_SYSTEM_NAME MATCHES "Linux")
-  target_link_libraries(antlr4_shared ${UUID_LIBRARIES})
-  target_link_libraries(antlr4_static ${UUID_LIBRARIES})
-elseif(APPLE)
+if(APPLE)
   target_link_libraries(antlr4_shared ${COREFOUNDATION_LIBRARY})
   target_link_libraries(antlr4_static ${COREFOUNDATION_LIBRARY})
 endif()
@@ -107,7 +104,7 @@ if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
 endif()
 
 set(static_lib_suffix "")
-if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
+if(CMAKE_CXX_COMPILER_ID MATCHES "MSVC" OR EMSCRIPTEN)
   set(static_lib_suffix "-static")
 endif()
 
diff --git a/runtime/Cpp/runtime/src/BufferedTokenStream.cpp b/runtime/Cpp/runtime/src/BufferedTokenStream.cpp
index 241dfe5..f65b1ce 100755
--- a/runtime/Cpp/runtime/src/BufferedTokenStream.cpp
+++ b/runtime/Cpp/runtime/src/BufferedTokenStream.cpp
@@ -374,15 +374,15 @@ std::string BufferedTokenStream::getText(const misc::Interval &interval) {
     stop = _tokens.size() - 1;
   }
 
-  std::stringstream ss;
+  std::string result;
   for (size_t i = start; i <= stop; i++) {
     Token *t = _tokens[i].get();
     if (t->getType() == Token::EOF) {
       break;
     }
-    ss << t->getText();
+    result.append(t->getText());
   }
-  return ss.str();
+  return result;
 }
 
 std::string BufferedTokenStream::getText(RuleContext *ctx) {
diff --git a/runtime/Cpp/runtime/src/DefaultErrorStrategy.cpp b/runtime/Cpp/runtime/src/DefaultErrorStrategy.cpp
index 54d35ee..f7d033e 100755
--- a/runtime/Cpp/runtime/src/DefaultErrorStrategy.cpp
+++ b/runtime/Cpp/runtime/src/DefaultErrorStrategy.cpp
@@ -101,7 +101,7 @@ void DefaultErrorStrategy::sync(Parser *recognizer) {
   size_t la = tokens->LA(1);
 
   // try cheaper subset first; might get lucky. seems to shave a wee bit off
-  auto nextTokens = recognizer->getATN().nextTokens(s);
+  const auto &nextTokens = recognizer->getATN().nextTokens(s);
   if (nextTokens.contains(Token::EPSILON) || nextTokens.contains(la)) {
     return;
   }
@@ -310,8 +310,7 @@ misc::IntervalSet DefaultErrorStrategy::getErrorRecoverySet(Parser *recognizer)
     // compute what follows who invoked us
     atn::ATNState *invokingState = atn.states[ctx->invokingState];
     const atn::RuleTransition *rt = downCast<const atn::RuleTransition*>(invokingState->transitions[0].get());
-    misc::IntervalSet follow = atn.nextTokens(rt->followState);
-    recoverSet.addAll(follow);
+    recoverSet.addAll(atn.nextTokens(rt->followState));
 
     if (ctx->parent == nullptr)
       break;
diff --git a/runtime/Cpp/runtime/src/RuleContext.cpp b/runtime/Cpp/runtime/src/RuleContext.cpp
index 3ed945f..a29e5f4 100755
--- a/runtime/Cpp/runtime/src/RuleContext.cpp
+++ b/runtime/Cpp/runtime/src/RuleContext.cpp
@@ -51,14 +51,14 @@ std::string RuleContext::getText() {
     return "";
   }
 
-  std::stringstream ss;
+  std::string result;
   for (size_t i = 0; i < children.size(); i++) {
     ParseTree *tree = children[i];
     if (tree != nullptr)
-      ss << tree->getText();
+      result.append(tree->getText());
   }
 
-  return ss.str();
+  return result;
 }
 
 size_t RuleContext::getRuleIndex() const {
diff --git a/runtime/Cpp/runtime/src/atn/ParserATNSimulator.cpp b/runtime/Cpp/runtime/src/atn/ParserATNSimulator.cpp
index c799150..b60dae3 100755
--- a/runtime/Cpp/runtime/src/atn/ParserATNSimulator.cpp
+++ b/runtime/Cpp/runtime/src/atn/ParserATNSimulator.cpp
@@ -583,8 +583,7 @@ ATNConfigSet* ParserATNSimulator::removeAllConfigsNotInRuleStopState(ATNConfigSe
     }
 
     if (lookToEndOfRule && config->state->epsilonOnlyTransitions) {
-      misc::IntervalSet nextTokens = atn.nextTokens(config->state);
-      if (nextTokens.contains(Token::EPSILON)) {
+      if (atn.nextTokens(config->state).contains(Token::EPSILON)) {
         ATNState *endOfRuleState = atn.ruleToStopState[config->state->ruleIndex];
         result->add(std::make_shared<ATNConfig>(*config, endOfRuleState), &mergeCache);
       }
diff --git a/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.cpp b/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.cpp
index 7160b59..f2a3fbe 100644
--- a/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.cpp
+++ b/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.cpp
@@ -47,28 +47,22 @@ Ref<const PredictionContext> PredictionContextMergeCache::put(
 
   auto [existing, inserted] = _entries.try_emplace(std::make_pair(key1.get(), key2.get()));
   if (inserted) {
-    try {
-      existing->second.reset(new Entry());
-    } catch (...) {
-      _entries.erase(existing);
-      throw;
-    }
-    existing->second->key = std::make_pair(key1, key2);
-    existing->second->value = std::move(value);
-    pushToFront(existing->second.get());
+    existing->second.key = std::make_pair(key1, key2);
+    existing->second.value = std::move(value);
+    pushToFront(&existing->second);
   } else {
-    if (existing->second->value != value) {
-      existing->second->value = std::move(value);
+    if (existing->second.value != value) {
+      existing->second.value = std::move(value);
     }
-    moveToFront(existing->second.get());
+    moveToFront(&existing->second);
   }
-  compact(existing->second.get());
-  return existing->second->value;
+  compact(&existing->second);
+  return existing->second.value;
 }
 
 Ref<const PredictionContext> PredictionContextMergeCache::get(
     const Ref<const PredictionContext> &key1,
-    const Ref<const PredictionContext> &key2) const {
+    const Ref<const PredictionContext> &key2) {
   assert(key1);
   assert(key2);
 
@@ -81,17 +75,17 @@ Ref<const PredictionContext> PredictionContextMergeCache::get(
   if (iterator == _entries.end()) {
     return nullptr;
   }
-  moveToFront(iterator->second.get());
-  return iterator->second->value;
+  moveToFront(&iterator->second);
+  return iterator->second.value;
 }
 
 void PredictionContextMergeCache::clear() {
-  Container().swap(_entries);
+  _entries.clear();
   _head = _tail = nullptr;
   _size = 0;
 }
 
-void PredictionContextMergeCache::moveToFront(Entry *entry) const {
+void PredictionContextMergeCache::moveToFront(Entry *entry) {
   if (entry->prev == nullptr) {
     assert(entry == _head);
     return;
diff --git a/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.h b/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.h
index efbeb10..88c0fc8 100644
--- a/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.h
+++ b/runtime/Cpp/runtime/src/atn/PredictionContextMergeCache.h
@@ -52,7 +52,7 @@ namespace atn {
                                      Ref<const PredictionContext> value);
 
     Ref<const PredictionContext> get(const Ref<const PredictionContext> &key1,
-                                     const Ref<const PredictionContext> &key2) const;
+                                     const Ref<const PredictionContext> &key2);
 
     const PredictionContextMergeCacheOptions& getOptions() const { return _options; }
 
@@ -76,7 +76,7 @@ namespace atn {
       Entry *next = nullptr;
     };
 
-    void moveToFront(Entry *entry) const;
+    void moveToFront(Entry *entry);
 
     void pushToFront(Entry *entry);
 
@@ -84,7 +84,7 @@ namespace atn {
 
     void compact(const Entry *preserve);
 
-    using Container = std::unordered_map<PredictionContextPair, std::unique_ptr<Entry>,
+    using Container = std::unordered_map<PredictionContextPair, Entry,
                                          PredictionContextHasher, PredictionContextComparer>;
 
     const PredictionContextMergeCacheOptions _options;
